\section*{\LARGE Chapter 2: Introductory Examples}
\addcontentsline{toc}{section}{\protect\textbf{\LARGE Chapter 2: Introductory Examples}}
\begin{abstract}
Trong chương này, một vài ví dụ và tập dữ liệu sẽ được đưa ra để phân tích để có cái nhìn tổng quan về việc phân tích dữ liệu.
\end{abstract}
\setcounter{section}{0}
\section{usa.gov data from bit.ly}
\quad Vào năm 2011, dịch vụ rút ngắn URL bit.ly đã hợp tác với trang web usa.gov của chính phủ Hoa Kỳ để lấy nguồn dữ liệu ẩn danh được thu thập từ những người dùng rút ngắn các liên kết có đuôi .gov hoặc .mil. Theo cách viết này, ngoài việc cung cấp nguồn cấp dữ liệu trực tiếp, ảnh chụp nhanh hàng giờ có sẵn dưới dạng tệp văn bản có thể tải xuống.\par
Trong trường hợp ảnh chụp nhanh hàng giờ, mỗi dòng trong mỗi tệp chứa một biến thể web phổ biến của dữ liệu được gọi là JSON, viết tắt của JavaScript Object Notation. Ví dụ: nếu chúng ta chỉ đọc tệp dấu đầu dòng, có thể thấy một cái gì đó như sau:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
path = 'bitly_usagov/example.txt'
open(path).readline()
\end{minted}
\quad Out: \\
\verb|'{ "a": "Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11 (KHTML, like Gecko) Ch|
\verb|rome\\/17.0.963.78 Safari\\/535.11", "c": "US", "nk": 1, "tz": "America\\/New_York", "gr":|
\verb|"MA", "g": "A6qOVH", "h": "wfLQtf", "l": "orofrog", "al": "en-US,en;q=0.8", "hh": "1.usa.g|
\verb|ov", "r": "http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf", "u": "http:\|
\verb|\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991", "t": 1331923247, "hc": 1331822918, "cy": "|
\verb|Danvers", "ll": [ 42.576698, -70.954903 ] }\n'|

\flushleft \quad Python có nhiều mô-đun tích hợp và bên thứ 3 để chuyển đổi một chuỗi JSON thành một đối tượng Python dictionary. Ở đây, mô-đun json và tải hàm của nó sẽ được gọi trên mọi dòng trong tệp mẫu phía trước:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
import json
path = 'bitly_usagov/example.txt'
records = [json.loads(line) for line in open(path)]
\end{minted}

\flushleft \quad Biểu thức cuối cùng ở trên(In [5])  được gọi là "a list comprehension", là một cách ngắn gọn để áp dụng một phép toán (như json.loads) vào một tập hợp các chuỗi hoặc các đối tượng khác. Một cách thuận tiện, việc lặp qua một trình xử lý tệp đang mở sẽ cung cấp cho chúng ta một chuỗi các dòng của nó. Các bản ghi đối tượng kết quả bây giờ là một danh sách các phân đoạn Python:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
records[0]
\end{minted}
\quad Out: \\
\verb|{'a': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/|
\verb|17.0.963.78 Safari/535.11',|\\
\verb|'c': 'US',| \\
\verb|'nk': 1,| \\
\verb|'tz': 'America/New_York',|\\
\verb|'gr': 'MA',|\\
\verb|'g': 'A6qOVH',|\\
\verb|'h': 'wfLQtf',|\\
\verb|'l': 'orofrog',|\\
\verb|'al': 'en-US,en;q=0.8',|\\
\verb|'hh': '1.usa.gov',|\\
\verb|'r': 'http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf',|\\
\verb|'u': 'http://www.ncbi.nlm.nih.gov/pubmed/22415991',|\\
\verb|'t': 1331923247,|\\
\verb|'hc': 1331822918,|\\
\verb|'cy': 'Danvers',|\\
\verb|'ll': [42.576698, -70.954903]}|\\

\flushleft \quad Lưu ý rằng các chỉ số Python bắt đầu từ 0 chứ không phải 1 như một số ngôn ngữ khác (như R). Giờ đây, thật dễ dàng để truy cập các giá trị riêng lẻ trong các bản ghi bằng cách chuyển một chuỗi cho từ khóa mà bạn muốn truy cập:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
records[0]['tz']
\end{minted}
\quad Out: \\
\verb|'America/New_York'|

\subsection{Counting Time Zones in Pure Python}
\quad Giả sử chúng ta quan tâm đến múi giờ xuất hiện thường xuyên nhất trong tập dữ liệu (trường tz). Có nhiều cách chúng ta có thể làm điều này. Đầu tiên, hãy trích xuất danh sách múi giờ một lần nữa bằng cách sử dụng khả năng hiểu danh sách (a list comprehension):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
time_zones = [rec['tz'] for rec in records]
\end{minted}
\quad Out: \\
---------------------------------------------------------------------------\\
KeyError                                  Traceback (most recent call last)\\
Input In [24], in <cell line: 1>()\\
----> 1 time\_zones = [rec['tz'] for rec in records]\\

Input In [24], in <listcomp>(.0)\\
----> 1 time\_zones = [rec['tz'] for rec in records]\\

KeyError: 'tz'\\
---------------------------------------------------------------------------\\

\quad Hóa ra không phải tất cả các bản ghi đều có trường múi giờ. Điều này rất dễ xử lý vì chúng ta có thể kiểm tra nếu 'tz' có trong rec vào cuối list comprehension:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
time_zones = [rec['tz'] for rec in records if 'tz' in rec]
time_zones[:10]
\end{minted}
\quad Out: \\
\verb|['America/New\_York',|\\
\verb|'America/Denver',|\\
\verb|'America/New\_York',|\\
\verb|'America/Sao\_Paulo',|\\
\verb|'America/New\_York',|\\
\verb|'America/New\_York',|\\
\verb|'Europe/Warsaw',|\\
\verb|'',|\\
\verb|'',|\\
\verb|'']|\\

\flushleft \quad Chỉ cần nhìn vào 10 múi giờ đầu tiên, chúng ta thấy rằng một số trong số đó là không xác định (trống).
chúng ta có thể lọc những thứ này ra. Để tính số lượng theo múi giờ, có hai cách tiếp cận: cách khó hơn (chỉ sử dụng thư viện chuẩn Python) và cách dễ hơn (sử dụng Pandas). Một cách để thực hiện việc đếm là sử dụng một mệnh lệnh để lưu trữ số lượng trong khi chúng ta lặp qua các múi giờ:

%viết code
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
def get_counts(sequence):
    counts = {}
    for x in sequence:
        if x in counts:
            counts[x] += 1
        else:
            counts[x] = 1
    return counts
\end{minted}

\quad Nếu bạn biết thêm một chút về thư viện chuẩn Python, bạn có thể thích viết điều tương tự ngắn gọn hơn:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
from collections import defaultdict

def get_counts2(sequence):
    counts = defaultdict(int) # values will initialize to 0
    for x in sequence:
        counts[x] += 1
    return counts
\end{minted}

\quad Để sử dụng nó trên các múi giờ, chỉ cần chuyển danh sách \texttt{times\_zones}:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
counts = get_counts(time_zones)
print(counts['America/New_York'])
print(len(time_zones))
\end{minted}
\quad Out: \\
\verb|1251|\\
\verb|3440|\\

\flushleft \quad Nếu chúng ta muốn có 10 múi giờ đầu tiên và số lượng của chúng, chúng ta phải thực hiện một chút sắp xếp trong từ điển:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
def top_counts(count_dict, n=10):
     value_key_pairs = [(count, tz) for tz, count in count_dict.items()]
     value_key_pairs.sort()
     return value_key_pairs[-n:]
\end{minted}
\quad Sau đó chúng ta có:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
top_counts(counts)
\end{minted}
\quad Out: \\
\verb|[(33, 'America/Sao_Paulo'),|\\
\verb|(35, 'Europe/Madrid'),|\\
\verb|(36, 'Pacific/Honolulu'),|\\
\verb|(37, 'Asia/Tokyo'),|\\
\verb|(74, 'Europe/London'),|\\
\verb|(191, 'America/Denver'),|\\
\verb|(382, 'America/Los_Angeles'),|\\
\verb|(400, 'America/Chicago'),|\\
\verb|(521, ''),|\\
\verb|(1251, 'America/New_York')]|\\

\flushleft\quad Nếu bạn tìm kiếm thư viện chuẩn Python, bạn có thể tìm thấy lớp \textbf{collection.Counter},  giúp cho tác vụ này trở nên dễ dàng hơn rất nhiều:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
from collections import Counter
counts = Counter(time_zones)
counts.most_common(10)
\end{minted}
\quad Out: \\
\verb|[('America/New_York', 1251),|\\
\verb|('', 521),|\\
\verb|('America/Chicago', 400),|\\
\verb|('America/Los_Angeles', 382),|\\
\verb|('America/Denver', 191),|\\
\verb|('Europe/London', 74),|\\
\verb|('Asia/Tokyo', 37),|\\
\verb|('Pacific/Honolulu', 36),|\\
\verb|('Europe/Madrid', 35),|\\
\verb|('America/Sao_Paulo', 33)]|\\

\subsection{Counting Time Zones with pandas}
\quad Cấu trúc dữ liệu chính của Pandas là DataFrame, bạn có thể coi đây là đại diện của Pandas cho một bảng hoặc bảng tính dữ liệu. Tạo DataFrame từ tập hợp các bản ghi ban đầu rất đơn giản:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
from pandas import DataFrame, Series
import pandas as pd
frame = DataFrame(records)
frame[:5]
\end{minted}
\quad Out: \\
\flushleft
\begin{tabular}{lllrll}
\toprule
{} &                                                  a &   c &   nk &                 tz &  gr \\
\midrule
0 &  Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... &  US &  1.0 &   America/New\_York &  MA \\
1 &                             GoogleMaps/RochesterNY &  US &  0.0 &     America/Denver &  UT    \\
2 &  Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... &  US &  1.0 &   America/New\_York &  DC     ...\\
3 &  Mozilla/5.0 (Macintosh; Intel Mac OS X 10\_6\_8)... &  BR &  0.0 &  America/Sao\_Paulo &  27 \\
4 &  Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... &  US &  0.0 &   America/New\_York &  MA \\
\bottomrule
\end{tabular}
\flushleft

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
frame['tz'][:10]
\end{minted}
\quad Out: \\
\verb|0     America/New_York|\\
\verb|1       America/Denver|\\
\verb|2     America/New_York|\\
\verb|3    America/Sao_Paulo|\\
\verb|4     America/New_York|\\
\verb|5     America/New_York|\\
\verb|6        Europe/Warsaw|\\
\verb|7|\\          
\verb|8|  \\                 
\verb|9|    \\                 
\verb|Name: tz, dtype: object|



\quad Đầu ra được hiển thị cho \textbf{frame} là dạng xem tóm tắt, được hiển thị cho các đối tượng DataFrame lớn. Đối tượng Series được trả về bởi \textbf{frame ['tz']}  có phương thức \texttt{value\_counts} cung cấp cho chúng ta những gì chúng ta đang tìm kiếm:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
tz_counts = frame['tz'].value_counts()
tz_counts[:10]
\end{minted}
\quad Out: \\
\verb|America/New_York       1251|\\
\verb|                        521|\\
\verb|America/Chicago         400|\\
\verb|America/Los_Angeles     382|\\
\verb|America/Denver          191|\\
\verb|Europe/London            74|\\
\verb|Asia/Tokyo               37|\\
\verb|Pacific/Honolulu         36|\\
\verb|Europe/Madrid            35|\\
\verb|America/Sao_Paulo        33|\\
\verb|Name: tz, dtype: int64|\\

\flushleft\quad   Sau đó, chúng ta có thể muốn tạo một biểu đồ của dữ liệu này bằng cách sử dụng thư viện vẽ biểu đồ, matplotlib. Bạn có thể thực hiện một chút thao tác để điền vào một giá trị thay thế cho dữ liệu múi giờ không xác định và bị thiếu trong bản ghi. Hàm fillna có thể thay thế các giá trị (NA) bị thiếu và các giá trị không xác định (chuỗi trống) có thể được thay thế bằng lập chỉ mục mảng boolean:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
clean_tz = frame['tz'].fillna('Missing')
clean_tz[clean_tz == ''] = 'Unknown'
tz_counts = clean_tz.value_counts()
tz_counts[:10]
\end{minted}
\quad Out: \\
\verb|America/New_York       1251|\\
\verb|                        521|\\
\verb|America/Chicago         400|\\
\verb|America/Los_Angeles     382|\\
\verb|America/Denver          191|\\
\verb|Missing                 120|\\
\verb|Europe/London            74|\\
\verb|Asia/Tokyo               37|\\
\verb|Pacific/Honolulu         36|\\
\verb|Europe/Madrid            35|\\
\verb|Name: tz, dtype: int64|\\




\flushleft\quad Tạo một biểu đồ thanh ngang có thể được thực hiện bằng cách sử dụng phương pháp biểu đồ trên các đối tượng đếm:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
tz_counts[:10].plot(kind='barh', rot=0)
\end{minted}


\quad Xem Hình 2.1 để biết kết quả. Chúng ta sẽ khám phá thêm các công cụ để làm việc với loại dữ liệu này. Ví dụ: trường chứa thông tin về trình duyệt, thiết bị hoặc ứng dụng được sử dụng để thực hiện rút ngắn URL:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
frame['a'][1]
\end{minted}
\quad Out: \\
\verb|'GoogleMaps/RochesterNY'|

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
frame['a'][50]
\end{minted}
\quad Out: \\
\verb|'Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2'|

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
frame['a'][51]
\end{minted}
\quad Out: \\
\verb|'Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P925/V10e Build/FRG83G)AppleWebKit/533.1|
\verb|(KHTML, like Gecko) Version/4.0 Mobile Safari/533.1'|


\flushleft
    \includegraphics[width = \textwidth]{viet_image/bieu do 2.1.png}
    \begin{center}
        \textit{Hình 2.1: Top time zones in the 1.usa.gov sample data}
    \end{center}


\quad Phân tích cú pháp tất cả các thông tin thú vị trong các chuỗi "agent" này có vẻ như là một nhiệm vụ khó khăn. Nhưng chúng ta có thể sử dụng các hàm chuỗi tích hợp sẵn của Python và khả năng biểu thức chính quy.  Ví dụ: chúng ta có thể tách mã thông báo đầu tiên trong chuỗi (tương ứng gần với khả năng của trình duyệt) và tạo một bản tóm tắt khác về hành vi của người dùng:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
results = Series([x.split()[0] for x in frame.a.dropna()])
results[:5]
\end{minted}
\quad Out: \\
\verb|0               Mozilla/5.0|\\
\verb|1    GoogleMaps/RochesterNY|\\
\verb|2               Mozilla/4.0|\\
\verb|3               Mozilla/5.0|\\
\verb|4               Mozilla/5.0|\\
\verb|dtype: object|

\flushleft
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
results.value_counts()[:8]
\end{minted}
\quad Out: \\
\verb|Mozilla/5.0                 2594|\\
\verb|Mozilla/4.0                  601|\\
\verb|GoogleMaps/RochesterNY       121|\\
\verb|Opera/9.80                    34|\\
\verb|TEST_INTERNET_AGENT           24|\\
\verb|GoogleProducer                21|\\
\verb|Mozilla/6.0                    5|\\
\verb|BlackBerry8520/5.0.0.681       4|\\
\verb|dtype: int64|\\

\flushleft\quad Bây giờ, giả sử ta muốn phân tách các múi giờ hàng đầu thành người dùng Windows và không phải Windows. Để đơn giản hóa, giả sử rằng một người dùng đang sử dụng Windows nếu chuỗi 'Windows' nằm trong chuỗi tác nhân. Vì một số tác nhân bị thiếu, ta sẽ loại trừ những tác nhân này khỏi dữ liệu:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
cframe = frame[frame.a.notnull()]
\end{minted}

\flushleft\quad Sau đó, chúng ta tính toán một giá trị cho dù mỗi hàng có phải là Windows hay không:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
operating_system = np.where(cframe['a'].str.contains('Windows'),'Windows', 'Not Windows')
operating_system
\end{minted}
\quad Out: \\
\verb|array(['Windows', 'Not Windows', 'Windows', ..., 'Not Windows','Not Windows', 'Windows'], |\\
\verb|dtype='<U11')|


\flushleft
\quad Sau đó, ta có thể nhóm dữ liệu theo cột múi giờ của nó và danh sách operating systems mới:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
by_tz_os = cframe.groupby(['tz', operating_system])
\end{minted}


\flushleft

\quad Số lượng nhóm, tương tự như hàm\textbf{ \texttt{value\_counts}} ở trên, có thể được tính bằng cách sử dụng \textbf{size}. Kết quả này sau đó được định hình lại thành một bảng với chức năng \textbf{unstack}:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
agg_counts = by_tz_os.size().unstack().fillna(0)
agg_counts[:3]
\end{minted}
\quad Out: \\
\flushleft
\begin{tabular}{lrr}
\toprule
{} &  Not Windows &  Windows \\
tz                &              &          \\
\midrule
                  &        245.0 &    276.0 \\
Africa/Cairo      &          0.0 &      3.0 \\
Africa/Casablanca &          0.0 &      1.0 \\
\bottomrule
\end{tabular}


\flushleft


\quad Cuối cùng, hãy chọn các múi giờ hàng đầu. Để làm như vậy, ta xây dựng một mảng chỉ mục gián tiếp từ số lượng hàng trong\texttt{ agg\_count}s:


\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
# Use to sort in ascending order
indexer = agg_counts.sum(1).argsort()
indexer[:10]
\end{minted}
\quad Out: \\
\verb|tz|\\
\verb|                                  24|\\
\verb|Africa/Cairo                      20|\\
\verb|Africa/Casablanca                 21|\\
\verb|Africa/Ceuta                      92|\\
\verb|Africa/Johannesburg               87|\\
\verb|Africa/Lusaka                     53|\\
\verb|America/Anchorage                 54|\\
\verb|America/Argentina/Buenos_Aires    57|\\
\verb|America/Argentina/Cordoba         26|\\
\verb|America/Argentina/Mendoza         55|\\
\verb|dtype: int64|\\


\flushleft

\quad Sau đó, ta sử dụng take để chọn các hàng theo thứ tự đó, sau đó cắt 10 hàng cuối cùng:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
count_subset = agg_counts.take(indexer)[-10:]
count_subset
\end{minted}
\quad Out: \\
\flushleft
\begin{tabular}{lrr}
\toprule
{} &  Not Windows &  Windows \\
tz                  &              &          \\
\midrule
America/Sao\_Paulo   &         13.0 &     20.0 \\
Europe/Madrid       &         16.0 &     19.0 \\
Pacific/Honolulu    &          0.0 &     36.0 \\
Asia/Tokyo          &          2.0 &     35.0 \\
Europe/London       &         43.0 &     31.0 \\
America/Denver      &        132.0 &     59.0 \\
America/Los\_Angeles &        130.0 &    252.0 \\
America/Chicago     &        115.0 &    285.0 \\
                    &        245.0 &    276.0 \\
America/New\_York    &        339.0 &    912.0 \\
\bottomrule
\end{tabular}



\flushleft


\quad Sau đó, như được hiển thị trong khối mã trước, điều này có thể được vẽ trong một biểu đồ thanh; Ta sẽ biến nó thành một biểu đồ thanh xếp chồng lên nhau bằng cách chuyển stacked = True (xem Hình 2.2):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
count_subset.plot(kind='barh', stacked=True)
\end{minted}
\flushleft
\quad Biểu đồ không giúp bạn dễ dàng nhìn thấy tỷ lệ phần trăm tương đối của người dùng Windows trong các nhóm nhỏ hơn, nhưng các hàng có thể dễ dàng được chuẩn hóa thành tổng thành 1 sau đó được vẽ lại (xem Hình 2.3):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
normed_subset = count_subset.div(count_subset.sum(1), axis=0)
normed_subset.plot(kind='barh', stacked=True)
\end{minted}



\flushleft
    \includegraphics[width = \textwidth]{viet_image/bieu do 2.2.png}
    \begin{center}
     \textit{Hình 2.2: Top time zones by Windows and non-Windows users}
    \end{center}

    \includegraphics[width = \textwidth]{viet_image/bieu do 2.3.png}
    \begin{center}
     \textit{Hình 2.3: Top time zones by Windows and non-Windows}
    \end{center}

\quad Tất cả các phương pháp được sử dụng ở đây sẽ được xem xét rất chi tiết trong suốt phần còn lại của cuốn sách.

\vspace{1cm}




\section{MovieLens 1M Data Set}
\quad GroupLens Research (http://www.grouplens.org/node/73) cung cấp một số tập hợp dữ liệu xếp hạng phim được thu thập từ người dùng MovieLens vào cuối những năm 1990 và đầu những năm 2000.

\vspace{0.5cm}
\quad Dữ liệu cung cấp xếp hạng phim, siêu dữ liệu phim (thể loại và năm) và
dữ liệu nhân khẩu học về người dùng (tuổi, mã zip, giới tính và nghề nghiệp). Dữ liệu như vậy thường quan tâm đến việc phát triển các hệ thống khuyến nghị dựa trên máy thuật toán học. 
             
\vspace{0.5cm}
\quad Sử dụng cách cắt và chia nhỏ các tập dữ liệu cần sử dụng.

\vspace{0.5cm}
\quad Tập dữ liệu 1 triệu MovieLens chứa 1 triệu xếp hạng được thu thập từ 6000 người dùng trên 4000 phim. Nó trải rộng trên 3 bảng: xếp hạng, thông tin người dùng và thông tin phim. Sau khi giải nén dữ liệu từ tệp zip, mỗi bảng có thể được tải vào một pandas.

\vspace{0.5cm}
\quad Đối tượng DataFrame sử dụng \texttt{pandas.read\_table}:\par

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
import pandas as pd

unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
users = pd.read_table('ml-1m/users.dat', sep='::', header=None,
                       names=unames)
rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
ratings = pd.read_table('ml-1m/ratings.dat', sep='::', header=None,
                       names=rnames)
mnames = ['movie_id', 'title', 'genres']
movies = pd.read_table('ml-1m/movies.dat', sep='::', header=None,
                        names=mnames)
\end{minted}

\vspace{0.5cm}
\quad Kiểm tra xem có thực hiện thành công hay không bằng cách truy xuất vài phần tử đầu tiên của DataFrame :

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
users[:5]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrlrrl}
\toprule
{} &  user\_id & gender &  age &  occupation &    zip \\
\midrule
0 &        1 &      F &    1 &          10 &  48067 \\
1 &        2 &      M &   56 &          16 &  70072 \\
2 &        3 &      M &   25 &          15 &  55117 \\
3 &        4 &      M &   45 &           7 &  02460 \\
4 &        5 &      M &   25 &          20 &  55455 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
ratings[:5]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrrr}
\toprule
{} &  user\_id &  movie\_id &  rating &  timestamp \\
\midrule
0 &        1 &      1193 &       5 &  978300760 \\
1 &        1 &       661 &       3 &  978302109 \\
2 &        1 &       914 &       3 &  978301968 \\
3 &        1 &      3408 &       4 &  978300275 \\
4 &        1 &      2355 &       5 &  978824291 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
movies[:5]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrll}
\toprule
{} &  movie\_id &                               title &                        genres \\
\midrule
0 &         1 &                    Toy Story (1995) &   Animation|Children's|Comedy \\
1 &         2 &                      Jumanji (1995) &  Adventure|Children's|Fantasy \\
2 &         3 &             Grumpier Old Men (1995) &                Comedy|Romance \\
3 &         4 &            Waiting to Exhale (1995) &                  Comedy|Drama \\
4 &         5 &  Father of the Bride Part II (1995) &                        Comedy \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
ratings
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrrr}
\toprule
{} &  user\_id &  movie\_id &  rating &  timestamp \\
\midrule
0 &        1 &      1193 &       5 &  978300760 \\
1 &        1 &       661 &       3 &  978302109 \\
2 &        1 &       914 &       3 &  978301968 \\
3 &        1 &      3408 &       4 &  978300275 \\
4 &        1 &      2355 &       5 &  978824291 \\
                    ...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Lưu ý rằng độ tuổi và nghề nghiệp được mã hóa dưới dạng số nguyên biểu thị các nhóm được mô tả trong
tệp README của tập dữ liệu. 

\vspace{0.5cm}
\quad Phân tích dữ liệu trải rộng trên ba bảng không phải là một việc đơn giản
nhiệm vụ. 

\vspace{0.5cm}
\quad \texttt{Ví dụ:} giả sử bạn muốn tính xếp hạng trung bình cho một bộ phim cụ thể
theo giới tính và độ tuổi. Như bạn sẽ thấy, điều này dễ thực hiện hơn nhiều với tất cả dữ liệu được hợp nhất
cùng nhau thành một bảng duy nhất. Sử dụng chức năng hợp nhất của gấu trúc, trước tiên, chúng chúng ta hợp nhất các xếp hạng với
sau đó người dùng hợp nhất kết quả đó với dữ liệu phim. pandas suy ra cột nào để
sử dụng làm khóa hợp nhất (hoặc nối) dựa trên tên chồng chéo:

\vspace{0.5cm}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
data = pd.merge(pd.merge(ratings, users), movies)
data
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrrrlrrlll}
\toprule
{} &  user\_id &  movie\_id &  rating &  timestamp & gender &  age &  occupation &    zip &                                   title \\
\midrule
0 &        1 &      1193 &       5 &  978300760 &      F &    1 &          10 &  48067 &  One Flew ... \\
1 &        2 &      1193 &       5 &  978298413 &      M &   56 &          16 &  70072 &  One Flew ... \\
2 &       12 &      1193 &       4 &  978220179 &      M &   25 &          12 &  32793 &  One Flew ... \\
3 &       15 &      1193 &       4 &  978199279 &      M &   25 &           7 &  22903 &  One Flew ... \\
4 &       17 &      1193 &       5 &  978158471 &      M &   50 &           1 &  95350 &  One Flew ... \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
data.iloc[0]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{ll}
user\_id    &                                       1 \\
movie\_id   &                                    1193 \\
rating     &                                       5 \\
timestamp  &                               978300760 \\
gender     &                                       F \\
age        &                                       1 \\
occupation &                                      10 \\
zip        &                                   48067 \\
title      &  One Flew Over the Cuckoo's Nest (1975) \\
genres     &                                   Drama \\
\end{tabular}\\
\vspace{0.5cm}
\quad Để xếp hạng cho từng bộ phim được nhóm theo giới tính, có thể sử dụng phương thức \texttt{pivot\_table}:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
mean_ratings = data.pivot_table('rating', index ='title', columns='gender', aggfunc='mean')
mean_ratings[:5]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
gender &         F &         M \\
title                         &           &           \\
\midrule
\$1,000,000 Duck (1971)        &  3.375000 &  2.761905 \\
'Night Mother (1986)          &  3.388889 &  3.352941 \\
'Til There Was You (1997)     &  2.675676 &  2.733333 \\
'burbs, The (1989)            &  2.793478 &  2.962085 \\
...And Justice for All (1979) &  3.828571 &  3.689024 \\
\bottomrule
\end{tabular}\\
\vspace{0.5cm}
\quad Điều này tạo ra một DataFrame khác chứa xếp hạng trung bình với các bộ phim là index và giới tính là columns. Đầu tiên, sẽ lọc ra những bộ phim nhận được ít nhất 250 xếp hạng, để làm điều này, nhóm dữ liệu theo tiêu đề và sử dụng size () để nhận Chuỗi kích thước nhóm cho mỗi tiêu đề:
\vspace{0.5cm}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
ratings_by_title = data.groupby('title').size()
ratings_by_title[:10]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lr}
\$1,000,000 Duck (1971)            &   37 \\
'Night Mother (1986)              &   70 \\
'Til There Was You (1997)         &   52 \\
'burbs, The (1989)                &  303 \\
...And Justice for All (1979)     &  199 \\
1-900 (1994)                      &    2 \\
10 Things I Hate About You (1999) &  700 \\
101 Dalmatians (1961)             &  565 \\
101 Dalmatians (1996)             &  364 \\
12 Angry Men (1957)               &  616 \\

\end{tabular}\\
\vspace{0.5cm}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
active_titles = ratings_by_title.index[ratings_by_title >= 250]
active_titles
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\verb|Index([''burbs, The (1989)', '10 Things I Hate About You (1999)',|\\
\verb|       '101 Dalmatians (1961)', '101 Dalmatians (1996)', '12 Angry Men (1957)',|\\
\verb|       '13th Warrior, The (1999)', '2 Days in the Valley (1996)',|\\
\verb|       '20,000 Leagues Under the Sea (1954)', '2001: A Space Odyssey (1968)',|\\
\verb|       '2010 (1984)',|\\
\verb|       ...|\\
\verb|       'X-Men (2000)', 'Year of Living Dangerously (1982)',|\\
\verb|       'Yellow Submarine (1968)', 'You've Got Mail (1998)',|\\
\verb|       'Young Frankenstein (1974)', 'Young Guns (1988)',|\\
\verb|       'Young Guns II (1990)', 'Young Sherlock Holmes (1985)',|\\
\verb|       'Zero Effect (1998)', 'eXistenZ (1999)'],|\\
\verb|      dtype='object', name='title', length=1216)|\\
\vspace{0.5cm}
\quad Sau đó, có thể chọn các hàng từ mean\_ratings ở trên:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
mean_ratings = mean_ratings.loc[active_titles]
mean_ratings
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrr}
\toprule
gender &         F &         M &      diff \\
title                             &           &           &           \\
\midrule
'burbs, The (1989)                &  2.793478 &  2.962085 &  0.168607 \\
10 Things I Hate About You (1999) &  3.646552 &  3.311966 & -0.334586 \\
101 Dalmatians (1961)             &  3.791444 &  3.500000 & -0.291444 \\
101 Dalmatians (1996)             &  3.240000 &  2.911215 & -0.328785 \\
12 Angry Men (1957)               &  4.184397 &  4.328421 &  0.144024 \\
...\\
\bottomrule
\end{tabular}\\
\vspace{0.5cm}
\quad Để xem những bộ phim hàng đầu của khán giả nữ, có thể sắp xếp theo cột F theo chiều giảm dần:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
top_female_ratings = mean_ratings.sort_values(by ='F', ascending=False)
top_female_ratings[:10]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
gender &         F &         M \\
title                                              &           &           \\
\midrule
Close Shave, A (1995)                              &  4.644444 &  4.473795 \\
Wrong Trousers, The (1993)                         &  4.588235 &  4.478261 \\
Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)      &  4.572650 &  4.464589 \\
Wallace \& Gromit: The Best of Aardman Animation... &  4.563107 &  4.385075 \\
Schindler's List (1993)                            &  4.562602 &  4.491415 \\
Shawshank Redemption, The (1994)                   &  4.539075 &  4.560625 \\
Grand Day Out, A (1992)                            &  4.537879 &  4.293255 \\
To Kill a Mockingbird (1962)                       &  4.536667 &  4.372611 \\
Creature Comforts (1990)                           &  4.513889 &  4.272277 \\
Usual Suspects, The (1995)                         &  4.513317 &  4.518248 \\
\bottomrule
\end{tabular}

\vspace{0.5cm}

\subsection{Measuring rating disagreement}
\quad Giả sử muốn tìm những bộ phim có sự khác biệt giữa người xem nam và nữ. Một cách là thêm một cột mean\_ratings vào và nó chứa sự khác biệt đó: 
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
mean_ratings['diff'] = mean_ratings['M'] - mean_ratings['F']
\end{minted} 
\\
\quad Sắp xếp theo 'diff' cho ta những bộ phim có sự chênh lệch xếp hạng lớn nhất và những phim nào được phụ nữ ưa thích:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
orted_by_diff = mean_ratings.sort_values(by='diff')
sorted_by_diff[:15]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrr}
\toprule
gender &         F &         M &      diff \\
title                                 &           &           &           \\
\midrule
Dirty Dancing (1987)                  &  3.790378 &  2.959596 & -0.830782 \\
Jumpin' Jack Flash (1986)             &  3.254717 &  2.578358 & -0.676359 \\
Grease (1978)                         &  3.975265 &  3.367041 & -0.608224 \\
Little Women (1994)                   &  3.870588 &  3.321739 & -0.548849 \\
Steel Magnolias (1989)                &  3.901734 &  3.365957 & -0.535777 \\
Anastasia (1997)                      &  3.800000 &  3.281609 & -0.518391 \\
Rocky Horror Picture Show, The (1975) &  3.673016 &  3.160131 & -0.512885 \\
Color Purple, The (1985)              &  4.158192 &  3.659341 & -0.498851 \\
Age of Innocence, The (1993)          &  3.827068 &  3.339506 & -0.487561 \\
Free Willy (1993)                     &  2.921348 &  2.438776 & -0.482573 \\
French Kiss (1995)                    &  3.535714 &  3.056962 & -0.478752 \\
Little Shop of Horrors, The (1960)    &  3.650000 &  3.179688 & -0.470312 \\
Guys and Dolls (1955)                 &  4.051724 &  3.583333 & -0.468391 \\
Mary Poppins (1964)                   &  4.197740 &  3.730594 & -0.467147 \\
Patch Adams (1998)                    &  3.473282 &  3.008746 & -0.464536 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Đảo ngược thứ tự của các hàng và cắt lại 15 hàng trên cùng, ta sẽ có được các bộ phim được nam giới ưa thích mà phụ nữ không đánh giá cao bằng:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
# Reverse order of rows, take first 15 rows
sorted_by_diff[::-1][:15]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrr}
\toprule
gender &         F &         M &      diff \\
title                                  &           &           &           \\
\midrule
Good, The Bad and The Ugly, The (1966) &  3.494949 &  4.221300 &  0.726351 \\
Kentucky Fried Movie, The (1977)       &  2.878788 &  3.555147 &  0.676359 \\
Dumb \& Dumber (1994)                   &  2.697987 &  3.336595 &  0.638608 \\
Longest Day, The (1962)                &  3.411765 &  4.031447 &  0.619682 \\
Cable Guy, The (1996)                  &  2.250000 &  2.863787 &  0.613787 \\
Evil Dead II (Dead By Dawn) (1987)     &  3.297297 &  3.909283 &  0.611985 \\
Hidden, The (1987)                     &  3.137931 &  3.745098 &  0.607167 \\
Rocky III (1982)                       &  2.361702 &  2.943503 &  0.581801 \\
Caddyshack (1980)                      &  3.396135 &  3.969737 &  0.573602 \\
For a Few Dollars More (1965)          &  3.409091 &  3.953795 &  0.544704 \\
Porky's (1981)                         &  2.296875 &  2.836364 &  0.539489 \\
Animal House (1978)                    &  3.628906 &  4.167192 &  0.538286 \\
Exorcist, The (1973)                   &  3.537634 &  4.067239 &  0.529605 \\
Fright Night (1985)                    &  2.973684 &  3.500000 &  0.526316 \\
Barb Wire (1996)                       &  1.585366 &  2.100386 &  0.515020 \\
\bottomrule
\end{tabular}


\vspace{0.5cm}
\quad Thay vào đó, giả sử muốn những bộ phim gây ra nhiều bất đồng nhất trong số người xem, không phụ thuộc vào giới tính. Sự bất đồng có thể được đo lường bằng phương sai hoặc độ lệch chuẩn của các xếp hạng:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
# Standard deviation of rating grouped by title
rating_std_by_title = data.groupby('title')['rating'].std()
# Filter down to active_titles
rating_std_by_title = rating_std_by_title.loc[active_titles]
# Order Series by value in descending order
rating_std_by_title.sort_values(ascending=False)[:10]
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lr}
title\\
Dumb \& Dumber (1994)                  &  1.321333 \\
Blair Witch Project, The (1999)       &  1.316368 \\
Natural Born Killers (1994)           &  1.307198 \\
Tank Girl (1995)                      &  1.277695 \\
Rocky Horror Picture Show, The (1975) &  1.260177 \\
Eyes Wide Shut (1999)                 &  1.259624 \\
Evita (1996)                          &  1.253631 \\
Billy Madison (1995)                  &  1.249970 \\
Fear and Loathing in Las Vegas (1998) &  1.246408 \\
Bicentennial Man (1999)               &  1.245533 \\
\end{tabular}
\vspace{0.5cm}

\quad Có thể nhận thấy rằng các thể loại phim được cung cấp dưới dạng một chuỗi phân tách bằng dấu sổ đứng (|). Nếu muốn thực hiện một số phân tích theo thể loại, sẽ cần nhiều công việc hơn để chuyển đổi thông tin thể loại thành một hình thức hữu ích hơn. 

\section{US Baby Names 1880-2010} 
\quad Cơ quan An sinh và xã hội Hoa kì (SSA) đã cung cấp đữ liệu về tần suất đặt tên cho trẻ sơ sinh từ năm 1880 đến nay. Hadley Wickham, tác giả của một số gói R phổ biến, thường sử dụng bộ dữ liệu này để minh họa thao tác dữ liệu trong R.
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
import numpy as np
import os
from pandas import Series, DataFrame
import pandas as pd
np.random.seed(12345)
import matplotlib.pyplot as plt
plt.rc('figure', figsize=(10, 6))
np.set_printoptions(precision=4, suppress=True)
\end{minted}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
names=['Name', 'sex', 'births', 'year']
#for year in range(1880, 2011, 1):
year = 1880
Names = pd.read_csv(r'names\yob{}.txt'.format(year),sep=',', names=names) 
Names['year'] = year
\end{minted}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
Names.head(10)
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllrr}
\toprule
{} &       Name & sex &  births &  year \\
\midrule
0 &       Mary &   F &    7065 &  1880 \\
1 &       Anna &   F &    2604 &  1880 \\
2 &       Emma &   F &    2003 &  1880 \\
3 &  Elizabeth &   F &    1939 &  1880 \\
4 &     Minnie &   F &    1746 &  1880 \\
5 &   Margaret &   F &    1578 &  1880 \\
6 &        Ida &   F &    1472 &  1880 \\
7 &      Alice &   F &    1414 &  1880 \\
8 &     Bertha &   F &    1320 &  1880 \\
9 &      Sarah &   F &    1288 &  1880 \\
\bottomrule
\end{tabular}

\vspace{0.5cm}

\quad Có nhiều điều bạn có thể muốn làm với tập dữ liệu:

\quad   - Hình dung tỷ lệ trẻ sơ sinh được đặt trong một tên cụ thể (tên của bạn hoặc tên khác) theo mốc thời gian.

\quad   - Xác định thứ hạng của một tên.

\quad   - Xác định 1 tên phổ biến nhất trong mỗi năm hoặc tên có mức tắng lớn nhất hoặc giảm.

\quad   - Xác định các xu hướng trong tên: nguyên âm, phụ âm, độ dài, sự da dạng tổng thể, những thay đổi trong chính tả, chữ cái đầu tiên và cuối cùng.

\quad   - Phân tích các xu hướng bên ngoài: Tên trong kinh thánh, người nổi tiếng, nhân khẩu học thay đổi.
\vspace{0.5cm}

\quad Bằng cách sử dụng các công cụ mà chúng ta đã xem xét cho đến nay, hầu hết các loại phân tích này đều rất đơn giản, vì vậy chúng ta sẽ hướng dẫn bạn nhiều trong số chúng. chúng ta khuyến khích bạn tải xuống và tự khám phá dữ liệu. Nếu bạn tìm thấy một mẫu thú vị trong dữ liệu, chúng ta rất muốn nghe về nó.
\vspace{0.5cm}

\quad Khi viết bài này, Cơ quan An sinh Xã hội Hoa Kỳ cung cấp các tệp dữ liệu có sẵn, mỗi năm một tệp, chứa tổng số ca sinh cho mỗi tổ hợp giới tính/tên. Kho lưu trữ thô của các tệp này có thể được lấy tại đây:
\vspace{0.5cm}

\quad http://www.ssa.gov/oact/babynames/limits.html
\vspace{0.5cm}

\quad Trong trường hợp trang này đã được di chuyển vào thời điểm bạn đang đọc nó, rất có thể nó sẽ được tìm lại bằng cách tìm kiếm trên Internet. Sau khi tải file “National data” names.zip về và giải nén ra, bạn sẽ có một thư mục chứa hàng loạt file dạng yob1880.txt. chúng ta sử dụng lệnh head của UNIX để xem 10 dòng đầu tiên của một trong các tệp (trên Windows, bạn có thể sử dụng lệnh conda install posix hoặc mở nó trong trình soạn thảo văn bản):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
conda install posix
!head -n 10 names/yob1880.txt
\end{minted}
\quad Out: \\
\verb|Mary,F,7065|\\
\verb|Anna,F,2604|\\
\verb|Emma,F,2003|\\
\verb|Elizabeth,F,1939|\\
\verb|Minnie,F,1746|\\
\verb|Margaret,F,1578|\\
\verb|Ida,F,1472|\\
\verb|Alice,F,1414|\\
\verb|Bertha,F,1320|\\
\verb|Sarah,F,1288|\\

\flushleft
\quad Vì đây là một biểu mẫu được phân tách bằng dấu phẩy độc đáo nên nó có thể được tải vào DataFrame với pandas.read csv

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
import pandas as pd
names1880 = pd.read_csv('names/yob1880.txt', names=['name', 'sex', 'births'])
names1880
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllr}
\toprule
{} &       name & sex &  births \\
\midrule
0 &       Mary &   F &    7065 \\
1 &       Anna &   F &    2604 \\
2 &       Emma &   F &    2003 \\
3 &  Elizabeth &   F &    1939 \\
4 &     Minnie &   F &    1746 \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Các tệp này chỉ chứa các tên có ít nhất 5 lần xuất hiện trong mỗi năm, vì vậy để đơn giản, chúng ta có thể sử dụng tổng của cột số lần sinh theo giới tính làm tổng số lần sinh trong năm đó:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
names1880.groupby('sex').births.sum()
\end{minted}
\quad Out: \\
\verb| sex|\\
\verb|F     90994|\\
\verb|M    110490|\\
\verb|Name: births, dtype: int64|\\
\flushleft
\quad Vì tập dữ liệu được chia thành các tệp theo năm nên một trong những điều đầu tiên cần làm là tập hợp tất cả dữ liệu vào một Khung dữ liệu duy nhất và hơn nữa là thêm trường năm . Điều này rất dễ thực hiện khi sử dụng pandas.concat:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
# 2010 is the last available year right now
years = range(1880, 2011)
pieces = []
columns = ['name', 'sex', 'births']
for year in years:
    path = 'names/yob%d.txt' % year
    frame = pd.read_csv(path, names=columns)
    frame['year'] = year
    pieces.append(frame)
# Concatenate everything into a single DataFrame
    names = pd.concat(pieces, ignore_index=True)
\end{minted}

\quad Có một vài điều cần lưu ý ở đây. Đầu tiên, hãy nhớ rằng concat dán các đối tượng DataFrame lại với nhau theo hàng theo mặc định. Thứ hai, bạn phải bỏ qua ignore index=True vì chúng chúng ta không quan tâm đến việc giữ nguyên số hàng ban đầu được trả về từ read csv. Vì vậy, bây giờ chúng chúng ta có một DataFrame rất lớn chứa tất cả dữ liệu tên: Bây giờ tên DataFrame trông giống như:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
names
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllrr}
\toprule
{} &       name & sex &  births &  year \\
\midrule
0 &       Mary &   F &    7065 &  1880 \\
1 &       Anna &   F &    2604 &  1880 \\
2 &       Emma &   F &    2003 &  1880 \\
3 &  Elizabeth &   F &    1939 &  1880 \\
4 &     Minnie &   F &    1746 &  1880 \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}


\quad Với dữ liệu này trong tay, chúng ta đã có thể bắt đầu tổng hợp dữ liệu ở cấp độ năm và giới tính bằng cách sử dụng groupby hoặc pivot table, xem Hình 2-4:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
total_births = names.pivot_table('births','year','sex', aggfunc=sum)
total_births.tail()
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
sex &        F &        M \\
year &          &          \\
\midrule
2006 &  1900375 &  2054352 \\
2007 &  1921655 &  2074427 \\
2008 &  1889800 &  2038995 \\
2009 &  1835873 &  1982310 \\
2010 &  1776223 &  1917416 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Tiếp theo, hãy chèn một giá trị cột với tỷ lệ trẻ sơ sinh được đặt cho mỗi tên so với tổng số ca sinh. Giá trị prop là 0,02 sẽ chỉ ra rằng cứ 100 trẻ sơ sinh thì có 2 trẻ được đặt một tên cụ thể. Vì vậy, chúng chúng ta nhóm dữ liệu theo năm và giới tính, sau đó thêm cột mới vào mỗi nhóm: def add\_prop(group):
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
def add_prop(group):
 # Integer division floors
 births = group.births.astype(float)
 group['prop'] = births / births.sum()
 return group
names = names.groupby(['year', 'sex']).apply(add_prop)
total_births.plot(title='Total births by sex and year')
\end{minted}
\quad Out: \\
\includegraphics[width = \textwidth]{viet_image/viet_anh 36.png}
\begin{center}
    \textit{Hình 2-4. Tổng số sinh theo giới tính và năm}
\end{center}

\quad Tập dữ liệu hoàn chỉnh kết quả hiện có các cột sau:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
names
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllrr}
\toprule
{} &       name & sex &  births &  year \\
\midrule
0 &       Mary &   F &    7065 &  1880 \\
1 &       Anna &   F &    2604 &  1880 \\
2 &       Emma &   F &    2003 &  1880 \\
3 &  Elizabeth &   F &    1939 &  1880 \\
4 &     Minnie &   F &    1746 &  1880 \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Khi thực hiện thao tác nhóm như thế này, việc kiểm tra độ chính xác thường rất có giá trị, chẳng hạn như xác minh rằng cột chống đỡ có tổng bằng 1 trong tất cả các nhóm. Vì đây là dữ liệu dấu chấm động, hãy sử dụng np.allclose để kiểm tra xem tổng của nhóm có đủ gần với (nhưng 
có lẽ không chính xác bằng) 1 hay không:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
np.allclose(names.groupby(['year', 'sex']).prop.sum(), 1)
\end{minted}
\quad Out: \\
\verb|True|\\

\flushleft
\quad Bây giờ điều này đã được thực hiện, chúng ta sẽ trích xuất một tập hợp con dữ liệu để tạo điều kiện cho phân tích sâu hơn: 1000 tên hàng đầu cho mỗi tổ hợp giới tính/năm. Đây là một thao tác nhóm khác:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
def get_top1000(group):
    return group.sort_index(kind='births', ignore_index = False)[:1000]
grouped = names.groupby(['year', 'sex'])
top1000 = grouped.apply(get_top1000)
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllllrr}
\toprule
     &   &   &       name & sex &  births &  year \\
year & sex & {} &            &     &         &       \\
\midrule
1880 & F & 0 &       Mary &   F &    7065 &  1880 \\
     &   & 1 &       Anna &   F &    2604 &  1880 \\
     &   & 2 &       Emma &   F &    2003 &  1880 \\
     &   & 3 &  Elizabeth &   F &    1939 &  1880 \\
     &   & 4 &     Minnie &   F &    1746 &  1880 \\
...\\
2010 & M & 1679125 &   Bailey &   M &     196 &  2010 \\
     &   & 1679126 &   Destin &   M &     196 &  2010 \\
     &   & 1679127 &  Eliezer &   M &     196 &  2010 \\
     &   & 1679128 &    Enoch &   M &     196 &  2010 \\
     &   & 1679129 &   Joziah &   M &     196 &  2010 \\
\bottomrule
\end{tabular}

\vspace{0.5cm}

\quad Nếu thích cách tiếp cận tự làm, bạn cũng có thể thực hiện:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
pieces = []
for year, group in names.groupby(['year', 'sex']):
    pieces.append(group.sort_index(kind='births', ignore_index = False)[:1000])
top1000 = pd.concat(pieces, ignore_index=True)
top1000
\end{minted}

\quad Tập dữ liệu kết quả bây giờ nhỏ hơn một chút:

\vspace{0.5cm}
\begin{tabular}{lllrr}
\toprule
{} &       name & sex &  births &  year \\
\midrule
0 &       Mary &   F &    7065 &  1880 \\
1 &       Anna &   F &    2604 &  1880 \\
2 &       Emma &   F &    2003 &  1880 \\
3 &  Elizabeth &   F &    1939 &  1880 \\
4 &     Minnie &   F &    1746 &  1880 \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Chúng chúng ta sẽ sử dụng tập dữ liệu Top 1000 này trong các cuộc điều tra về dữ liệu sau đây.
\subsection{Analyzing Naming Trends} 

\quad Dữ liệu đầy đủ và tập dữ liệu Top 1.000 trong tay, chúng ta có thể bắt đầu phân tích các xu hướng đặt tên khác nhau được quan tâm. Trước tiên, việc chia 1.000 tên hàng đầu thành các phần nam và nữ rất dễ thực hiện:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
boys = top1000[top1000.sex == 'M']
girls = top1000[top1000.sex == 'F']
\end{minted}

\quad Chuỗi thời gian đơn giản, chẳng hạn như số lượng Johns hoặc Marys cho mỗi năm có thể được vẽ trên biểu đồ nhưng yêu cầu trộn lẫn một chút để hữu ích hơn một chút. Hãy tạo một bảng tổng hợp tổng số lần sinh theo năm và tên:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
total_births = top1000.pivot_table('births','year','name',aggfunc=sum)
\end{minted}

\quad Bây giờ, điều này có thể được vẽ cho một số tên bằng cách sử dụng phương thức vẽ của DataFrame:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
total_births
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
sex &       F &       M \\
year &         &         \\
\midrule
1880 &   90994 &  110490 \\
1881 &   91953 &  100737 \\
1882 &  107847 &  113686 \\
1883 &  112319 &  104625 \\
1884 &  129019 &  114442 \\
1885 &  133055 &  107799 \\
1886 &  144533 &  110784 \\
1887 &  145982 &  101411 \\
1888 &  178622 &  120851 \\
1889 &  178366 &  110580 \\
...\\
\bottomrule
\end{tabular}
\vspace{0.5cm}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
subset = total_births[['John', 'Harry', 'Mary', 'Marilyn']]
subset.plot(subplots=True, figsize=(12, 10), grid=False,title="Number of births per year")
\end{minted}

\quad Xem Hình 2-5 để biết kết quả. Khi nhìn vào điều này, bạn có thể kết luận rằng những cái tên này đã không còn được ưa chuộng đối với người dân Mỹ. Nhưng câu chuyện thực sự phức tạp hơn thế, sẽ được khám phá trong phần tiếp theo.

\includegraphics[width = \textwidth]{viet_image/viet_anh 46.png}
\begin{center}
    \textit{Hình 2-5. Một vài tên con trai và con gái theo thời gian}
\end{center}

\subsection{Measuring the increase in naming diversity}
\quad Trong cách đặt tên Một lời giải thích cho sự sụt giảm trong các lô ở trên là do ngày càng ít cha mẹ chọn tên phổ biến cho con cái của họ. Giả thuyết này có thể được khám phá và xác nhận trong dữ liệu. Một thước đo là tỷ lệ sinh được đại diện bởi 1000 tên phổ biến nhất mà chúng ta tổng hợp và vẽ biểu đồ theo năm và giới tính:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
table = top1000.pivot_table('prop', 'year','sex', aggfunc=sum)
table.plot(title='Sum of table1000.prop by year and sex',yticks=np.linspace(0, 1.2, 13), 
                                    xticks=range(1880, 2020, 10))
\end{minted}

\quad Xem Hình 2-6 cho biểu đồ này. Vì vậy, bạn có thể thấy rằng, trên thực tế, dường như có sự 
đa dạng về tên ngày càng tăng (giảm tổng tỷ lệ trong top 1.000). Một vấn đề thú vị khác 
là số lượng các tên riêng biệt, được tính theo thứ tự phổ biến từ cao nhất đến thấp nhất, 
trong 1 nửa trường hợp sinh nhiều nhất. Con số này khó tính toán hơn một chút. Hãy xem xét các tên con trai từ năm 2010::

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
df = boys[boys.year == 2010]
df
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lllrrr}
\toprule
{} &       name & sex &  births &  year &      prop \\
\midrule
260876 &      Jacob &   M &   22139 &  2010 &  0.011546 \\
260877 &      Ethan &   M &   18008 &  2010 &  0.009392 \\
260878 &    Michael &   M &   17366 &  2010 &  0.009057 \\
260879 &     Jayden &   M &   17191 &  2010 &  0.008966 \\
260880 &    William &   M &   17060 &  2010 &  0.008897 \\
260881 &  Alexander &   M &   16759 &  2010 &  0.008740 \\
260882 &       Noah &   M &   16463 &  2010 &  0.008586 \\
260883 &     Daniel &   M &   15853 &  2010 &  0.008268 \\
260884 &      Aiden &   M &   15544 &  2010 &  0.008107 \\
260885 &    Anthony &   M &   15501 &  2010 &  0.008084 \\
...\\
\bottomrule
\end{tabular}

\vspace{0.5cm}

\includegraphics[width = \textwidth]{viet_image/viet_anh 48.png}
\begin{center}
    \textit{Hình 2-6. Tỷ lệ trẻ em được sinh ra trong top 1000 tên theo giới tính}
\end{center}
\quad Sau khi sắp xếp prop theo thứ tự giảm dần, chúng chúng ta muốn biết cần bao nhiêu cái tên phổ biến nhất để đạt được 1 nửa. Bạn có thể viết một vòng lặp for để thực hiện việc này, nhưng cách NumPy được vector hóa thông minh hơn một chút. Lấy tổng tích lũy, cumsum, của prop sau đó gọi phương thức searchsorted trả về vị trí trong tổng tích lũy mà tại đó 0,5 sẽ cần được chèn vào để giữ nó theo thứ tự được sắp xếp:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
prop_cumsum = df.sort_index(kind='births', ignore_index = False).prop.cumsum()
prop_cumsum[:10]
\end{minted}
\quad Out: \\
\verb|260876    0.011546|\\
\verb|260877    0.020938|\\
\verb|260878    0.029995|\\
\verb|260879    0.038961|\\
\verb|260880    0.047858|\\
\verb|260881    0.056599|\\
\verb|260882    0.065185|\\
\verb|260883    0.073453|\\
\verb|260884    0.081559|\\
\verb|260885    0.089644|\\
\verb|Name: prop, dtype: float64|\\
\flushleft
\quad Vì các mảng không được lập chỉ mục, nên việc thêm 1 vào kết quả này sẽ cho bạn kết quả là 117. Ngược lại, vào năm 1900, con số này nhỏ hơn nhiều:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
df = boys[boys.year == 1900]
in1900 = df.sort_index(kind='births', ignore_index = False).prop.cumsum()
in1900.searchsorted(0.5) + 1
\end{minted}
\quad Out: \\
\verb|25|\\

\flushleft
\quad Giờ đây, việc áp dụng thao tác này cho tổ hợp năm/giới tính sẽ khá đơn giản; nhóm các trường đó và áp dụng một hàm trả về số lượng cho mỗi nhóm:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
def get_quantile_count(group, q=0.5):
    group = group.sort_index(kind='births', ignore_index = False)
    return group.prop.cumsum().searchsorted(q) + 1
diversity = top1000.groupby(['year', 'sex']).apply(get_quantile_count)
diversity = diversity.unstack('sex')
\end{minted}

\quad Sự đa dạng DataFrame kết quả này hiện có hai chuỗi thời gian, một chuỗi cho mỗi giới tính, được lập chỉ mục theo năm. Điều này có thể được kiểm tra trong IPython và được vẽ như trước (xem Hình 2-7):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
diversity.head()
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
sex &   F &   M \\
year &     &     \\
\midrule
1880 &  38 &  14 \\
1881 &  38 &  14 \\
1882 &  38 &  15 \\
1883 &  39 &  15 \\
1884 &  39 &  16 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
diversity.plot(title="Number of popular names in top 50%")
\end{minted}
\quad Out: \\
\begin{center}
    \includegraphics[width = \textwidth]{viet_image/viet_anh 54.png}
    \textit{Hình 2-7. Tỷ lệ tên con trai và con gái qua từng năm}
\end{center}

\quad Như bạn có thể thấy, tên con gái luôn đa dạng hơn tên con trai và chúng chỉ trở nên đa dạng hơn theo thời gian. Phân tích sâu hơn về chính xác những gì đang thúc đẩy sự đa dạng, chẳng hạn như sự gia tăng các cách viết thay thế, dành cho người đọc.

\subsection{The “Last letter” Revolution}

\quad Vào năm 2007, nhà nghiên cứu về tên trẻ em Laura Wattenberg đã chỉ ra trên trang web của mình (http://www.babynamewizard.com) rằng việc phân bổ tên của con trai theo chữ cái cuối cùng đã thay đổi đáng kể trong 100 năm qua. Để thấy điều này, trước tiên chúng ta tổng hợp tất cả các ca sinh trong bộ dữ liệu đầy đủ theo năm, giới tính và chữ cái cuối cùng:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
# extract last letter from name column
get_last_letter = lambda x: x[-1]
last_letters = names.name.map(get_last_letter)
last_letters.name = 'last_letter'
table = names.pivot_table('births',last_letters,['sex', 'year'], aggfunc=sum)
\end{minted}

\flushleft
\quad Sau đó, chúng ta chọn ra ba năm tiêu biểu trải dài và in vài năm đầu tiên.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
subtable = table.reindex(columns=[1910, 1960, 2010], level='year')
subtable.head()
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrrrrr}
\toprule
sex & \multicolumn{3}{l}{F} & \multicolumn{3}{l}{M} \\
year &      1910 &      1960 &      2010 &     1910 &      1960 &      2010 \\
last\_letter &           &           &           &          &           &           \\
\midrule
a           &  108399.0 &  691285.0 &  677176.0 &    977.0 &    5214.0 &   28888.0 \\
b           &       NaN &     694.0 &     455.0 &    411.0 &    3910.0 &   39298.0 \\
c           &       5.0 &      49.0 &     957.0 &    482.0 &   15456.0 &   23360.0 \\
d           &    6751.0 &    3732.0 &    2645.0 &  22112.0 &  262106.0 &   44856.0 \\
e           &  133601.0 &  435009.0 &  316921.0 &  28665.0 &  178742.0 &  130325.0 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Tiếp theo, chuẩn hóa bảng theo tổng số ca sinh để tính một bảng mới chứa tỷ lệ tổng số ca sinh cho mỗi giới tính kết thúc bằng mỗi chữ cái:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
subtable.sum()
\end{minted}
\quad Out: \\
\verb|sex  year|\\
\verb|F    1910     396505.0|\\
\verb|     1960    2022001.0|\\
\verb|     2010    1776223.0|\\
\verb|M    1910     194209.0|\\
\verb|     1960    2131990.0|\\
\verb|     2010    1917416.0|\\
\verb|dtype: float64|\\
\flushleft
\quad Với tỷ lệ chữ cái hiện có trong tay, chúng ta có thể tạo các biểu đồ thanh cho từng giới tính được chia nhỏ theo năm. Xem Hình 2-8:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
import matplotlib.pyplot as plt
letter_prop = subtable / subtable.sum().astype(float)
fig, axes = plt.subplots(2, 1, figsize=(10, 8))
letter_prop['M'].plot(kind='bar', rot=0, ax=axes[0], title='Male')
letter_prop['F'].plot(kind='bar', rot=0, ax=axes[1], title='Female',legend=False)
\end{minted}

\includegraphics[width = \textwidth]{viet_image/viet anh s2.png}
\begin{center}
    \textit{Hình 2-8. Tỷ lệ tên con trai và con gái kết thúc trong mỗi chữ cái}
\end{center}


\quad Như bạn có thể thấy, những tên con trai kết thúc bằng chữ “n” đã có sự phát triển đáng kể kể từ những năm 1960. Quay trở lại bảng đầy đủ đã tạo ở trên, chúng ta lại chuẩn hóa theo năm và giới tính và chọn một tập hợp con các chữ cái cho tên con trai, cuối cùng chuyển đổi để biến mỗi cột thành một chuỗi thời gian:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
letter_prop = table / table.sum().astype(float)
import pandas
dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T
dny_ts.head()
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrrr}
\toprule
last\_letter &         d &         n &         y \\
year &           &           &           \\
\midrule
1880 &  0.083057 &  0.153217 &  0.075763 \\
1881 &  0.083246 &  0.153221 &  0.077459 \\
1882 &  0.085332 &  0.149561 &  0.077538 \\
1883 &  0.084053 &  0.151656 &  0.079149 \\
1884 &  0.086122 &  0.149927 &  0.080408 \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Với DataFrame của chuỗi thời gian này trong tay, chúng ta có thể tạo lại biểu đồ xu hướng theo thời gian bằng phương pháp biểu đồ của nó (xem Hình 2-9):

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
dny_ts.plot()
\end{minted}


\includegraphics[width = \textwidth]{viet_image/viet_anh 60.png}
\begin{center}
    \textit {Hình 2-9. Tỷ lệ trẻ trai sinh ra có tên kết thúc bằng d/n/y theo thời gian}
\end{center}


\subsection{Boy names that became girl names (and vice versa)}

\vspace{0.5cm}
\quad Một xu hướng thú vị khác là xem xét các tên con trai phổ biến hơn với một giới tính trước đó trong mẫu nhưng đã "thay đổi giới tính" trong hiện tại. Một ví dụ là tên Lesley hoặc Leslie. Quay trở lại tập dữ liệu top1000 , chúng ta tính toán danh sách các tên xuất hiện trong tập dữ liệu bắt đầu bằng 'lesl':

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
all_names = top1000.name.unique()
mask = np.array(['lesl' in x.lower() for x in all_names])
lesley_like = all_names[mask]
lesley_like
\end{minted}
\quad Out: \\
\verb|array(['Leslie', 'Lesley', 'Leslee', 'Lesli', 'Lesly'], dtype=object)|
\flushleft
\quad Từ đó, chúng ta có thể lọc xuống chỉ những tên đó và tính tổng số lần sinh được nhóm theo tên để xem tần suất tương đối:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
filtered = top1000[top1000.name.isin(lesley_like)]
filtered.groupby('name').births.sum()
\end{minted}
\quad Out: \\
\verb|name|\\
\verb|Leslee       993|\\
\verb|Lesley     34983|\\
\verb|Lesli        929|\\
\verb|Leslie    370581|\\
\verb|Lesly      10072|\\
\verb|Name: births, dtype: int64|\\
\flushleft
\quad Tiếp theo, hãy tổng hợp theo giới tính và năm và chuẩn hóa trong vòng một năm:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
table = filtered.pivot_table('births','year','sex', aggfunc='sum')
table = table.div(table.sum(1), axis=0)
table.tail()
\end{minted}
\quad Out: \\
\vspace{0.5cm}
\begin{tabular}{lrr}
\toprule
sex &    F &   M \\
year &      &     \\
\midrule
2006 &  1.0 & NaN \\
2007 &  1.0 & NaN \\
2008 &  1.0 & NaN \\
2009 &  1.0 & NaN \\
2010 &  1.0 & NaN \\
\bottomrule
\end{tabular}
\vspace{0.5cm}

\quad Cuối cùng, giờ đây, thật dễ dàng để lập biểu đồ phân tích theo giới tính theo thời gian (Hình 2-10):
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=backcolour,
fontsize=\footnotesize,
linenos
]
{python}
table.plot(style={'M': 'k-', 'F': 'k--'})
\end{minted}
\quad Out: \\
\includegraphics[width = \textwidth]{viet_image/viet_anh 64.png}
\begin{center}
    \textit{Hình 2-10. Tỷ lệ nam/nữ có tên giống Lesley theo thời gian}
\end{center}


\section{Conclusions and The Path Ahead}
\vspace{0.5cm}
\quad Các ví dụ trong chương này khá đơn giản, nhưng chúng ở đây để cung cấp cho bạn một chút hương vị về những thứ bạn có thể mong đợi trong các chương sắp tới. Trọng tâm của cuốn sách này là về các công cụ thay vì trình bày các phương pháp phân tích phức tạp hơn.Nắm vững các kỹ thuật trong cuốn sách này sẽ cho phép bạn thực hiện các phân tích của riêng mình (giả sử bạn biết mình muốn làm gì!) trong thời gian ngắn.
$ gcc $